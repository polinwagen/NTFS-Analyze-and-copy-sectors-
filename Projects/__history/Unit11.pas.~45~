unit Unit11;

interface


uses
 Classes,Windows, Messages, SysUtils, Variants,  Graphics, Controls, Forms,
  Dialogs, StdCtrls, FileCtrl,ComCtrls, Buttons, ShellAPI;

type
  TForm11 = class(TForm)
    DriveComboBox1: TDriveComboBox;
    DirectoryListBox1: TDirectoryListBox;
    FileListBox1: TFileListBox;
    Button1: TButton;
    Label1: TLabel;
    SpeedButton1: TSpeedButton;
    Label2: TLabel;
    Label3: TLabel;
    DriveComboBox2: TDriveComboBox;
    Label4: TLabel;
    BitBtn7: TBitBtn;
    BitBtn2: TBitBtn;
    procedure Button1Click(Sender: TObject);
    procedure DriveComboBox1Change(Sender: TObject);
    procedure DirectoryListBox1Change(Sender: TObject);
    procedure BitBtn7Click(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure BitBtn2Click(Sender: TObject);

  private
  public
   procedure Search;
     procedure UnPack;
    { Public declarations }
  end;

var
SerialNum: dword;
 VolumeName, FSName : array [0..255] of char;
 MaximumFNameLength,FileSystemFlags:dword;
 CurCluster:DWORD;
 //
  Form11: TForm11;
  s,s1:PWidechar;

  hDevice:THandle;
  buf1: array [0..108000] of byte;
  bResult:LongBool;
  lpBytesReturned:DWORD;
  FS: TFileStream;
  BS,attr,atrlenght:array [0..7] of byte;
  DATA:array [0..512] of byte;
  I,j,attrhead:byte;
  bootsect,mftbyte:int64;
  count,num,offset,t,first:integer;
  atroffset,atrhead,lenght:integer;
  select: array [0..20] of String;
  cloffs,frstcl,lstcl:array[0..10] of int64; // смещение.первый кластер.последний кластер
  mfcloffs,mffrstcl,mflstcl:array[0..10] of int64;   // перенос для хранения значений отрезков DATA mft
  directoryf,CurrentName:string[100];
  FileName:string[50];
  DirectoryNames:array [1..20] of string[50];
  sr: TSearchRec;
implementation
 uses Unit12, ABOUT;
{$R *.dfm}

procedure TForm11.BitBtn2Click(Sender: TObject);
begin
 form11.Close;
end;

procedure TForm11.BitBtn7Click(Sender: TObject);
begin
ShellExecute(0, 'open', Pchar(ExtractFilePath(Application.ExeName) + 'help.chm'), nil, nil, SW_MAXIMIZE);
end;

procedure TForm11.Button1Click(Sender: TObject);
begin
  s:=Pchar('\\.\'+form11.DriveCombobox1.Drive+':');

   bResult:=GetVolumeInformation(s, VolumeName, SizeOf(VolumeName),
                         @SerialNum,
                         MaximumFNameLength,
                       FileSystemFlags,
                       FSName, SizeOf(FSName)) ;

  //читаем Boot-сектор диска-оригинала
hDevice:=CreateFile(s, GENERIC_READ, FILE_SHARE_READ or FILE_SHARE_WRITE,nil,OPEN_EXISTING,0,0);
 if hDevice=INVALID_HANDLE_VALUE    then begin ShowMessage(IntToStr(GetLastError)); exit; end;
  FillChar(buf1,sizeof(buf1),0);
 if(hDevice<>INVALID_HANDLE_VALUE) then begin
  SetFilePointer(hDevice,0,nil,FILE_BEGIN);
 bResult:=ReadFile(hDevice,buf1,512,lpBytesReturned,nil);
 end;
  j:=0;   //BootSector
 for I := 48 to 55  do
 begin
 BS[j]:=buf1[I];
 inc(j);
  end;
j:=0;
bootsect:=int64(BS);  //первый кластер mft


mftbyte:=bootsect*8*512;
// считаем атрибут data из mft значение его 80h
//считаем всю mft

  FillChar(buf1,sizeof(buf1),0);
 if(hDevice<>INVALID_HANDLE_VALUE) then begin
  SetFilePointerEx(hDevice,mftbyte,nil,FILE_BEGIN);
  bResult:=ReadFile(hDevice,buf1,1024,lpBytesReturned,nil); //читаем mft
 end;

 attrhead:=$80;

  Search(); //Загружаем в массив DATA содержимое атрибута DATA

                //раскрываем список отрезков DATA
   offset:=64; // список отрезков начинается по смещению в атрибуте DATA с позиции 40h

   UnPack(); // получаем список отрезков атрибута DATA таблицы mft
            //cloffs,frstcl,lstcl-кластерное смещение,первыйкластер,последний кластер


    for I := 0 to 10 do
  begin
   mfcloffs[I]:=  cloffs[I];
   mffrstcl[I]:= frstcl[I];
   mflstcl[I]:= lstcl[I];
  end;



if AnsiCompareText(FSName,'FAT32')=0
then begin
   ShowMessage(S);
  ShowMessage('Файловая система FAT32 не поддерживается');
  exit;
  end;


 j:=1;
 for I := 0 to 20 do
  select[i]:='';
  num:=0;
 CurrentName:=ExtractFileName(DirectoryListBox1.Directory); //имя открытого каталога
 FileName:=ExtractFileDir(ExpandUNCFileName(CurrentName));
 first:=4;
 for I := 1 to length(FileName) do
 begin
  if FileName[first+I]='\' then
  begin
  DirectoryNames[j]:=copy(FileName,first,I);
  first:=first+I+1;
  inc(j);
  end;
 end;
 j:=0;

 for I := 0 to (FileListBox1.Items.Count-1) do
 begin
   if FileListBox1.Selected[i] then
    begin
     select[num]:=ExtractFileName(FileListBox1.Items[i]); //имена файлов в массиве
     num:=num+1;
    end;

 end;

t:=FileListBox1.Items.Count;

if FindFirst('C:\'+CurrentName +'\'+ '*.*', faAnyFile, sr) = 0 then
  begin
    repeat
    if (sr.Attr and faDirectory) <> 0 then  // если найденный файл - папка
      begin
      if (sr.Name <> '.') and (sr.Name <> '..') then  // игнорировать служебные папки
        begin
        filename:= sr.Name;
        end;
      end;
    until FindNext(sr) <> 0;
  end;
FindClose(sr);

 if select[0]='' then
 begin
  ShowMessage('Не выбран ни один файл');
  exit;
 end;

 Form12.Show ;

 end;


























procedure TForm11.DirectoryListBox1Change(Sender: TObject);
begin
FileListBox1.Directory := DirectoryListBox1.Directory;
end;

procedure TForm11.DriveComboBox1Change(Sender: TObject);
begin
DirectoryListBox1.Drive := DriveComboBox1.Drive;
end;



procedure TForm11.Search;  //процедура поиска атрибута  DATA и его считывание в массив
var
I,j:integer;

begin
 j:=0;   //смещение первого атрибута
 for I := 20 to 21  do
 begin
 attr[j]:=buf1[I];
 inc(j);
  end;
 j:=0;
 atroffset:=int64(attr);

  while buf1[atroffset]<>attrhead do
   begin
     j:=0;


        for I := atroffset+4 to atroffset+7 do  // если заголовок не соответствует 80h то,вычисляем длину атр

             begin
              atrlenght[j]:=buf1[I];
              inc(j);
             end;



      atroffset:=int64(atrlenght)+atroffset;

  end;
        j:=0;


        for I := atroffset+4 to atroffset+7 do

             begin
              atrlenght[j]:=buf1[I];
              inc(j);
             end;

       lenght:=int64(atrlenght);


         j:=0;

          for I :=atroffset to atroffset+ lenght do  //считываем все DATA
             begin
              DATA[j]:=buf1[I];
              inc(j);
             end;



end;

procedure TForm11.SpeedButton1Click(Sender: TObject);
begin
AboutBox.ShowModal;
end;

procedure TForm11.UnPack;
 var
 lo,hi,analyz:byte;
 firstcluster,clusteroffset,lastcluster: array [0..7] of byte;
 I1,I,j:byte;


     begin
       I1:=0;
       j:=0;

         FillChar(firstcluster,sizeof(firstcluster),0);
         FillChar(clusteroffset,sizeof(clusteroffset),0);
         FillChar(lastcluster,sizeof(lastcluster),0);

       while DATA[offset]<>0 do
       begin
        analyz:=DATA[offset];
        hi:=(analyz and  $F0)shr 4; //размер начального кластера (старшие 4 разряда)
        lo:=analyz and $0F; //размер смещения (младшие 4 разряда)
         for I := offset+1 to offset+lo do
            begin
            clusteroffset[j]:=DATA[I];
            inc(j);
           end;
           j:=0;

           cloffs[I1]:=int64(clusteroffset);



         for I := offset+1+lo to offset+lo+hi do
           begin
            firstcluster[j]:=DATA[I];
            inc(j);
           end;
           j:=0;

           frstcl[I1]:=int64(firstcluster);

           if I1>0 then
            frstcl[I1]:=  frstcl[I1]+ frstcl[I1-1];

           lstcl[I1]:=frstcl[I1]+cloffs[I1];
           offset:=offset+lo+hi+1;
           inc(I1);

        end;

     end;



end.
